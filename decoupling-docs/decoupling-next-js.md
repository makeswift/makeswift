# May 12 - Gemini Output

**This document is generated by Gemini 2.5 Pro.** We uploaded our runtime repo using [Repomix](https://github.com/yamadashy/repomix) along with the “Decoupling Next.js” project pitch.

# **1. Introduction**

The `@makeswift/runtime` package is currently tightly coupled with the Next.js framework. This integration has historically facilitated rapid development and provided a rich feature set for Next.js users. However, evolving business requirements necessitate exploring the use of Makeswift with other frameworks (e.g., Stencil) and even in vanilla React environments.

This document is the outcome of a research and development (R&D) initiative aimed at:

- Identifying and cataloging the specific points where `@makeswift/runtime` depends on Next.js.
- Proposing general strategies for decoupling these dependencies.
- Estimating the relative difficulty of decoupling each identified point.

The ultimate goal of this broader initiative is to refactor `@makeswift/runtime` into a framework-agnostic core library, with Next.js-specific functionalities isolated into a separate adapter package (e.g., `@makeswift/runtime-next-adapter`). This document serves as a technical foundation for a subsequent production-mode project to execute this decoupling.

# **2. Methodology**

The analysis was conducted by:

1. Reviewing the project pitch to understand the known areas of coupling and project goals.
2. Performing a comprehensive scan of the `@makeswift/runtime` codebase (provided as a single XML file) to identify Next.js-specific imports, API usage, patterns, and conventions.
3. Categorizing these dependencies and aligning them with the coupling points mentioned in the project pitch.
4. Formulating high-level decoupling strategies and difficulty estimations for each point.

Keywords and patterns searched for included: `next/router`, `next/link`, `next/image`, `next/head`, `next/document`, `next/cache`, `next/headers`, `next/navigation`, `NextApiRequest`, `NextApiResponse`, `NextRequest`, `NextResponse`, `previewData`, `draftMode`, and inspection of files within the `src/next/` directory.

# **3. Identified Coupling Points, Decoupling Strategies, and Difficulty Estimations**

The following sections detail each identified point of coupling between `@makeswift/runtime` and Next.js.

**3.1. Routing and Locale Handling**

- **Description:** The runtime relies on Next.js for determining the current URL pathname and locale, especially in the Pages Router. This information is crucial for fetching the correct page data and resolving localized resources.
- **Code References:**
  - `src/components/hooks/useRouterLocaleSync.ts`: Uses `next/router`'s `useRouter()` to get the current locale and synchronize it with the internal state via `dispatch(setLocale(...))`.
  - `src/next/hooks/use-is-pages-router.ts`: Directly imports and calls `useRouter()` from `next/router` to differentiate behavior.
  - `src/next/client.ts`: The `Makeswift.getPageSnapshot()` and `Makeswift.getComponentSnapshot()` methods accept a `locale` option, which is typically derived from Next.js's routing context (`ctx.locale` in `getStaticProps`). The client then uses this locale for fetching localized page pathname slices and global elements.
  - `src/next/api-handler/handlers/redirect-preview.ts`: Accesses `req.query.path` which is a Next.js Pages Router specific pattern for accessing the original path after a rewrite, often used with localized routes.
- **Impact of Coupling:** The runtime's ability to understand and operate in a localized context is tied to Next.js's routing and i18n capabilities.
- **Decoupling Strategy:**
  1. **Core Runtime:**
     - Modify core data-fetching functions (like those in `Makeswift` client) to always require `pathname` and `locale` (nullable for default) as explicit parameters.
     - The internal state management for locale (e.g., `src/state/actions.ts -> setLocale`, `src/locale.ts`) appears largely framework-agnostic and can be retained.
  2. **Framework Adapter (e.g.,** `@makeswift/runtime-next-adapter`):
     - This adapter would be responsible for obtaining the `pathname` and `locale` from the specific Next.js router environment (`useRouter` for Pages, `params` and `headers` for App Router) and passing them to the core runtime.
  3. **Other Frameworks:** Each framework adapter would implement its own logic for determining the current path and locale.
- **Difficulty Estimation:** Medium.
  - Core logic changes are straightforward (parameterizing functions).
  - Adapter logic for Next.js is manageable.
  - The main complexity lies in ensuring consistent behavior and clear documentation for how other frameworks should provide this context.

**3.2. Draft & Preview Mode**

- **Description:** The system for viewing draft content or previewing unpublished changes is heavily reliant on Next.js's Preview Mode (Pages Router) and Draft Mode (App Router). This includes signed cookies, specific API routes for enabling/disabling these modes, and reading preview/draft state.
- **Code References:**
  - `src/next/preview-mode.tsx`: `getMakeswiftSiteVersion(previewData)` parses Next.js `PreviewData`.
  - `src/next/draft-mode/index.tsx`: `getSiteVersion()` uses `cookies()` and `draftMode()` from `next/headers` (App Router). `MAKESWIFT_DRAFT_MODE_DATA_COOKIE` is defined here.
  - `src/next/api-handler/handlers/utils/draft.ts`: Defines Next.js-specific cookie names (`__prerender_bypass`, `PREVIEW_DATA_COOKIE`) and Makeswift's `MAKESWIFT_DRAFT_DATA_COOKIE`. Uses `cookieSettingOptions` which are tailored for secure, cross-site cookies often required by Next.js preview/draft modes.
  - `src/next/api-handler/handlers/redirect-draft.ts`: App Router specific logic using `draftMode().enable()`, `cookies()`, and `NextResponse.redirect`.
  - `src/next/api-handler/handlers/redirect-preview.ts`: Pages Router specific logic using `res.setPreviewData()` and `res.redirect()`.
  - `src/next/api-handler/handlers/clear-draft.ts`: Clears Next.js related draft/preview cookies.
  - `src/runtimes/react/components/draft-switcher/`: UI for exiting preview/draft mode, relies on the `/api/makeswift/clear-draft` endpoint.
  - `src/runtimes/react/components/hooks/use-builder-handshake.ts`: Differentiates handshake messages based on whether it's Pages or App Router.
- **Impact of Coupling:** Fundamental preview capabilities are tied to Next.js's secure cookie and state management for these modes.
- **Decoupling Strategy:**
  1. **Core Runtime:**
     - The core runtime should be initialized with or accept a `siteVersion: MakeswiftSiteVersion` (Live or Working) parameter for all data-fetching operations. This determines which version of content to request from the Makeswift API.
     - The core should be unaware of how this `siteVersion` is determined (cookies, query params, etc.).
  2. **Framework Adapter (**`@makeswift/runtime-next-adapter`):
     - Handles all Next.js specific logic: reading `previewData` (Pages), using `draftMode()` (App), managing associated cookies.
     - Implements the API routes (`/api/makeswift/draft`, `/api/makeswift/preview`, `/api/makeswift/clear-draft`) using Next.js primitives.
     - Could host the `DraftSwitcher` UI or provide hooks for it.
  3. **Other Frameworks:**
     - This will be a significant challenge. Options include:
       - Relying on query parameters (e.g., `?makeswift_preview_secret=<KEY>&site_version=Working`). This is less secure and might have issues with caching.
       - Requiring the host application to implement its own secure session/cookie mechanism to convey the preview state to its server-side logic, which then passes the correct `siteVersion` to the Makeswift client.
       - For purely client-side rendering, the `siteVersion` could be set based on a query parameter or `window.location.hash`, but API keys would be exposed.
- **Difficulty Estimation:** High. Preview/draft mode is intrinsically linked to server-side state and secure mechanisms that Next.js provides. A general, secure solution for other environments is non-trivial.

**3.3. HTTP API Endpoints**

- **Description:** Several crucial backend functionalities (manifest, fonts, resource fetching, revalidation, webhooks) are exposed as HTTP endpoints implemented using Next.js API routes.
- **Code References:**
  - `src/next/api-handler/index.ts`: `MakeswiftApiHandler` is the central dispatcher for these routes, designed for both Pages and App Router conventions.
  - All files under `src/next/api-handler/handlers/`:
    - `manifest.ts`: Returns runtime capabilities.
    - `fonts.ts`: Serves custom fonts.
    - `element-tree.ts`: For copying element trees (used in templates/duplication).
    - `revalidate.ts`, `webhook/index.ts`: For cache invalidation.
    - Resource proxying (implicit): The handler also proxies requests for swatches, files, typographies, etc., (e.g., `client.getSwatch` calls `/api/makeswift/swatches/:id`).
- **Impact of Coupling:** The entire server-side communication infrastructure between the Makeswift builder/services and the host application relies on Next.js API routes.
- **Decoupling Strategy:**
  1. **Core Logic Extraction:**
     - The actual business logic within each handler (e.g., processing a webhook payload, fetching a font definition) should be extracted into pure functions or classes that are independent of Next.js request/response objects.
     - These core functions would operate on simple data structures.
  2. **API Client Configuration:**
     - `MakeswiftHostApiClient` (`src/api/react.ts`) and `Makeswift` client (`src/next/client.ts`) currently assume endpoints are at `/api/makeswift/...`. This base path must become configurable.
  3. **Framework Adapter (**`@makeswift/runtime-next-adapter`):
     - Provides the Next.js API route implementations. These routes would call the extracted core logic functions, handling the translation between Next.js's `NextApiRequest`/`NextRequest` and the generic inputs for the core functions, and similarly for responses.
  4. **Other Frameworks:**
     - Host applications using other frameworks would need to implement their own server endpoints that invoke the same core logic functions. This implies the core logic needs to be easily callable from various backend environments (e.g., Express, Fastify, serverless functions).
     - For fully static/client-side scenarios, some of these endpoints might be omitted (e.g., revalidation) or proxied through a separate backend service if direct client-to-Makeswift-API communication is not desired for key-protected operations.
- **Difficulty Estimation:** Medium to High. Extracting logic is feasible. The main effort is defining clean, generic interfaces for the core handlers and ensuring the Next.js adapter correctly implements the HTTP layer. Providing guidance for other backends adds complexity.

**3.4. Cache Revalidation (On-Demand ISR & Tag-Based)**

- **Description:** The runtime uses Next.js's advanced caching features, specifically on-demand ISR (`revalidatePath`) and tag-based revalidation (`revalidateTag`), to keep pages updated after changes in Makeswift.
- **Code References:**
  - `src/next/api-handler/handlers/revalidate.ts`: Implements an endpoint that calls `next/cache.revalidatePath`.
  - `src/next/api-handler/handlers/webhook/site-published.ts`: Calls `next/cache.revalidateTag(MAKESWIFT_CACHE_TAG)` upon receiving a site publish webhook.
  - `src/next/cache.ts`: Defines `MAKESWIFT_CACHE_TAG`.
  - `src/next/client.ts` (internal `fetch` method): Adds `MAKESWIFT_CACHE_TAG` to `fetch` requests' `next.tags` option. This allows Next.js's data cache to associate fetched Makeswift data with this tag for revalidation.
- **Impact of Coupling:** Cache invalidation strategies are highly specific to Next.js's Data Cache and ISR mechanisms.
- **Decoupling Strategy:**
  1. **Core Runtime:** Should not be responsible for cache revalidation. It can signal that data has changed (e.g., via a callback after a webhook is processed), but the revalidation action itself is a framework concern.
  2. **Framework Adapter (**`@makeswift/runtime-next-adapter`):
     - The webhook handler within the adapter would be responsible for calling `revalidateTag` and/or `revalidatePath`.
     - The fetch wrapper (if the adapter implements one for Makeswift API calls) would add Next.js-specific cache tags.
  3. **Other Frameworks:**
     - This functionality will be highly dependent on the target framework's capabilities.
     - If the framework has a similar ISR/revalidation system, the adapter would use it.
     - If not, alternatives include:
       - Time-based revalidation (stale-while-revalidate).
       - Manual redeploys triggered by webhooks.
       - Custom cache invalidation logic (e.g., clearing a Redis cache or purging a CDN).
     - Makeswift might need to provide more granular webhook data if specific paths need to be revalidated by external systems.
- **Difficulty Estimation:** High. This is deeply tied to Next.js's architecture. The best approach is likely to make this an adapter-specific feature. Core runtime would be unaware of it.

**3.5. Head Element Management and SSR Styling**

- **Description:** The runtime manages HTML `<head>` elements (metadata, links, styles, scripts) using Next.js-specific components (`next/head` for Pages Router) and hooks (`useServerInsertedHTML` for App Router with Emotion CSS).
- **Code References:**
  - `src/next/document.tsx`: Custom `_document.js` for Pages Router, integrating `@emotion/server` for SSR style extraction.
  - `src/next/root-style-registry.tsx`: Context provider for App Router using `useServerInsertedHTML` to inject Emotion styles during SSR. This also provides the Emotion cache via `useCache`.
  - `src/next/components/head-tags.tsx`: Contains `PageTitle`, `PageMeta`, `PageLink`, `PageStyle`. These components adapt their rendering based on whether they are in Pages Router (using `next/head`) or App Router (rendering tags directly, leveraging React 18's built-in head support and `precedence` for styles/links).
  - `src/components/page/PageHead.tsx`: Orchestrates the use of the above `head-tags` components to render page-specific metadata and styles.
  - `src/components/page/HeadSnippet.tsx`: Handles rendering of custom HTML snippets in the head, with similar conditional logic for `next/head` and `useServerInsertedHTML`.
  - `src/runtimes/react/use-global-style.ts` and `src/runtimes/react/use-style.ts`: Core Emotion styling hooks that consume the cache provided by `RootStyleRegistry` (for App Router) or implicitly work with Emotion's global cache (which `_document.js` handles for Pages Router).
- **Impact of Coupling:** SSR of dynamic styles and `<head>` content is deeply intertwined with Next.js rendering lifecycle.
- **Decoupling Strategy:**
  1. **Core Runtime:**
     - Should generate a structured, serializable representation of all required `<head>` elements (e.g., an array of objects like `{ tag: 'title', children: 'Page Title' }`, `{ tag: 'meta', props: { name: 'description', content: '...' } }`, `{ tag: 'style', children: 'css_string', props: { 'data-emotion': '...' } }`).
     - For CSS-in-JS (Emotion): The core can generate CSS strings. Critical CSS extraction for SSR without Next.js's specific hooks (`getInitialProps` or RSC mechanisms) would be the main challenge. It might need to expose a way to get all registered styles.
  2. **Framework Adapter (**`@makeswift/runtime-next-adapter`):
     - Takes the structured head data from the core.
     - Renders it using `next/head` for Pages Router.
     - Renders it directly (or via helper components like `src/next/components/head-tags.tsx` adapted for the adapter) for App Router.
     - Manages Emotion SSR: For Pages Router, the adapter would provide the custom `_document.js` setup. For App Router, it would provide the `RootStyleRegistry`.
  3. **Other Frameworks:**
     - The host application or its adapter would consume the head data structure.
     - Rendering methods:
       - Server-side: Using templating engine capabilities.
       - Client-side: Direct DOM manipulation (e.g., for React apps, libraries like `react-helmet-async`).
     - Emotion SSR: Would require a custom setup for each framework, potentially involving manual style extraction using `@emotion/server` if the framework has a way to hook into the SSR process. If not, styles might only apply client-side, leading to FOUC.
- **Difficulty Estimation:** High. Head management and especially CSS-in-JS SSR are complex and framework-dependent.

**3.6. Built-in Components with Next.js Dependencies**

- **Image Component (**`src/components/builtin/Image/Image.tsx`):
  - **Description:** Directly uses `next/image` (both `next/image` and `next/legacy/image`) for optimized image rendering. The `imageSizes` utility function is tailored for `next/image`'s `sizes` prop.
  - **Impact:** The primary image rendering capability is tied to Next.js's infrastructure.
  - **Decoupling Strategy:**
    1. **Core Runtime:**
       - Define a `<MakeswiftImageBase>` component that renders a standard `<img>` tag, taking common attributes like `src`, `alt`, `width`, `height`, `loading`, `style`.
       - The core `@makeswift/controls.Image` control should resolve to props suitable for this base component.
    2. **Framework Adapter (**`@makeswift/runtime-next-adapter`):
       - Provide a `<MakeswiftNextImage>` component. This component would either wrap `<MakeswiftImageBase>` and adapt its props for `next/image`, or directly use `next/image` if the prop transformation is too complex. It would handle `priority`, `sizes`, `quality`, `loader`, etc.
    3. **Runtime Registration Mechanism:** The core runtime should allow a "default image component" to be registered by an adapter. When the `Image` control is used, its resolved value would be props for this registered component. The Next.js adapter would register its `next/image`-based component.
  - **Difficulty Estimation:** Medium. Creating a good base `<img>` component is easy. The adapter part for `next/image` retains existing functionality. The challenge is in the registration mechanism and ensuring props are correctly mapped and typed.
- **Link Component (**`src/components/shared/Link/index.tsx`):
  - **Description:** Uses `next/link` for client-side navigation enhancements. It also contains logic to handle Pages Router vs. App Router differences (e.g., `locale: false` prop for Pages Router `next/link`).
  - **Impact:** Enhanced navigation (prefetching, client-side transitions) is tied to `next/link`.
  - **Decoupling Strategy:**
    1. **Core Runtime:**
       - Define a `<MakeswiftLinkBase>` component that renders a standard `<a>` tag with `href`, `target`, etc.
       - The core `@makeswift/controls.Link` control (after its own decoupling, see `src/controls/link.ts`) should resolve to props suitable for this base component.
    2. **Framework Adapter (**`@makeswift/runtime-next-adapter`):
       - Provide a `<MakeswiftNextLink>` component that wraps the base component or directly uses `next/link`, handling its specific props.
    3. **Runtime Registration Mechanism:** Similar to the Image component, allow registration of a "default link component".
  - **Difficulty Estimation:** Medium. The base `<a>` tag is simple. The adapter maintains Next.js benefits. The registration and prop mapping need care.

**3.7. Build System and Packaging**

- **Description:** The current build process (`tsup.config.ts`) and `package.json` `exports` are structured to output Next.js-specific submodules (e.g., `next/plugin`, `next/server`, `next/document`).
- **Impact:** The physical structure of the published package reflects the Next.js coupling.
- **Decoupling Strategy:**
  1. `@makeswift/runtime-core`: A new package containing all framework-agnostic logic. This would be the primary dependency for non-Next.js integrations.
     - `src/api/` (with `GraphQLClient` made more configurable)
     - `src/builder/`
     - `src/components/` (with `Image` and `Link` refactored as base versions)
     - `src/controls/` (potentially some, if not all, moved to `@makeswift/controls` further)
     - `src/state/` (core state modules)
     - `src/runtimes/react/` (core React runtime logic, hooks like `useIsInBuilder`, but not `useReactRuntime` which implies a provider from an adapter)
     - `src/utils/`
  2. `@makeswift/runtime-next-adapter` (or similar name):
     - Contains all code currently in `src/next/`.
     - Provides Next.js-specific implementations for `Image`, `Link`, Head management, API handlers, preview/draft mode logic.
     - Exports a `NextReactRuntime` (or similar) that extends/configures the core runtime and provides the `ReactRuntimeProvider` for Next.js apps.
     - Would depend on `@makeswift/runtime-core`.
  3. `@makeswift/runtime` (current package):
     - **Option A (Meta-package):** Could become a meta-package that re-exports from `@makeswift/runtime-core` and `@makeswift/runtime-next-adapter` for backward compatibility. This might be complex to maintain.
     - **Option B (Becomes Core):** The current `@makeswift/runtime` is refactored to become the core package, and `@makeswift/runtime-next-adapter` is a new, separate package. This is cleaner for new adapters but is a breaking change for existing Next.js users (they'd need to install and import from the adapter for Next-specific things). The project pitch hints at this direction ("move these dependencies into a separate package").
- **Difficulty Estimation:** Medium. Involves significant refactoring of the build setup, package structure, and careful management of internal vs. public APIs across packages.

**3.8. Implicit Dependencies in Client/Runtime Initialization**

- **Description:** The `ReactRuntimeProvider` (`src/runtimes/react/components/RuntimeProvider.tsx`) and the `MakeswiftHostApiClient` (`src/api/react.ts`) are initialized with `previewMode`, `locale`, `apiOrigin`, etc. While these are passed as props, their typical source in examples is Next.js context. The API client's default URI for GraphQL also assumes the `/api/makeswift/graphql` path.
- **Impact:** Setup and configuration are currently demonstrated with Next.js in mind.
- **Decoupling Strategy:**
  1. The existing props (`previewMode`, `locale`) on `ReactRuntimeProvider` are good abstractions. This pattern should be maintained.
  2. The `MakeswiftHostApiClient`'s `uri` for GraphQL should be explicitly required or have a more generic default, with documentation emphasizing its configurability. Currently, it defaults to `https://api.makeswift.com/graphql` but the relative paths for resource fetching in `fetchAPIResource` (in `src/state/makeswift-api-client.ts`) assume local proxying via `/api/makeswift/...`. These paths should also be configurable or derived from a base API URL for the host.
- **Difficulty Estimation:** Low. Mostly involves ensuring defaults are framework-agnostic and documentation is clear for non-Next.js setups.

# **4. Proposed Phased Decoupling Roadmap (High-Level)**

1. **Phase 1: Core Logic Isolation & Configuration Enhancement (Difficulty: Medium)**
   - Refactor `MakeswiftHostApiClient` and internal fetchers to use fully configurable base URLs for proxied API endpoints.
   - Ensure core `Makeswift` client (`src/next/client.ts`, to be moved to core) methods like `getPageSnapshot` take `siteVersion` and `locale` as explicit inputs, removing any internal Next.js-specific lookups.
   - Isolate core logic from `src/next/api-handler/handlers/*` into utility functions.
2. **Phase 2: Component and Control Abstraction (Difficulty: Medium)**
   - Create base versions of `Image` and `Link` components.
   - Develop a runtime registration mechanism for these components, allowing adapters to provide framework-specific implementations.
   - Review all controls to ensure their resolved values are framework-agnostic data structures.
3. **Phase 3: Adapters for Next.js - API & Preview (Difficulty: High)**
   - Develop the Next.js adapter, implementing:
     - API route handlers using the extracted core logic.
     - Preview/Draft mode integration by calling core runtime with `siteVersion` derived from Next.js mechanisms.
     - Registration of Next.js-specific `Image` and `Link` components.
4. **Phase 4: Adapters for Next.js - Head & Styling (Difficulty: High)**
   - Core runtime generates a head tag data structure.
   - Next.js adapter implements rendering these tags (using `next/head`, direct rendering, `RootStyleRegistry`).
   - Next.js adapter handles Emotion cache and SSR style extraction.
5. **Phase 5: Packaging, Testing, and Documentation (Difficulty: Medium)**
   - Split into `@makeswift/runtime-core` and `@makeswift/runtime-next-adapter`.
   - Thoroughly test both packages.
   - Update all documentation for the new architecture, including guides for Next.js users (using the adapter) and initial guidance for developers wanting to build adapters for other frameworks.
   - Create a proof-of-concept with a simple non-Next.js React setup (e.g., Vite + Express) to validate the core package's agnosticism.

# **5. Conclusion**

Decoupling `@makeswift/runtime` from Next.js is a significant architectural refactor. The most challenging areas involve replacing Next.js's infrastructure for preview/draft mode, API routing, on-demand cache revalidation, and SSR styling/head management. However, by isolating core logic and adopting a framework-adapter pattern, it is feasible to achieve a more versatile runtime.

The proposed phased approach prioritizes abstracting core functionalities first, then building out the Next.js adapter, and finally restructuring the packaging. This R&D spike confirms the feasibility and provides a solid foundation for a production project to undertake this decoupling. The primary benefit will be the ability to expand Makeswift's reach to a wider range of web development ecosystems.
